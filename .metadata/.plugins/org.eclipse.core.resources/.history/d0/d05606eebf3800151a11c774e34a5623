import java.util.*;

import tester.Tester;

// lab 06 
// http://www.ccs.neu.edu/course/cs2510su13-1/labs/lab6.html

// Ex 01

// REPRESENTS: a list
interface IList <X> {
	// RETURNS: a list like this one, but with the given elements added
	IList<X> add(X elem);
	
	// RETURNS: a list like this one, but with elements equal to the given one
	// removed
	IList<X> sub(X elem);
	
	// RETURNS: true iff this list contains at least an element equal to the given
	// one
	boolean contains(X elem);
	
	// RETURNS: true iff this list contains all elements in that list
	boolean containsList(IList<X> that);
	
	// RETURNS: true iff this list is empty
	boolean empty();
	
	// RETURNS: the first element of this list
	X first();
	
	// RETURNS: a list like this one, but with the first element removed
	IList<X> rest();
	
	// RETURNS: the result of traversal this list
	<R> R traversal(IListVisitor<X, R> v);
}


class Mt <X> implements IList<X> {
	Mt() {}
	
	// RETURNS: a list like this one, but with the given elements added
	public IList<X> add(X elem) {
		return new Cons<X>(elem, this); 
	}
	
	// RETURNS: a list like this one, but with elements equal to the given one
	// removed
	public IList<X> sub(X elem) {
		return this;
	}
	
	// RETURNS: true iff this list contains at least an element equal to the given
	// one
	public boolean contains(X elem) {
		return false;
	}
	
	// RETURNS: the result of traversal this list
	public <R> R traversal(IListVisitor<X, R> v) {
		return v.processMt(this);
	}
	
	// RETURNS: true iff this list contains all elements in that list
	public boolean containsList(IList<X> that) {
		return false;
	}
	
	// RETURNS: true iff this list is empty
	public boolean empty() {
		return true;
	}
	
	
	// RETURNS: the first element of this list
	public X first() {
		throw new RuntimeException("Mt<X>.first()");
	}
	
	// RETURNS: a list like this one, but with the first element removed
	public IList<X> rest() {
		throw new RuntimeException("Mt<X>.rest()");
	}
}

class Cons <X> implements IList<X> {
	private X fst;
	private IList<X> rst;
	
	Cons(X fst, IList<X> rst) {
		this.fst = fst;
		this.rst = rst;
	}
	
	// RETURNS: a list like this one, but with the given elements added
	public IList<X> add(X elem) {
		return new Cons<X>(elem, this);
	}
	
	// RETURNS: a list like this one, but with elements equal to the given one
	// removed
	public IList<X> sub(X elem) {
		if(this.fst.equals(elem)) {
			return this.rst.sub(elem);
		}
		else {
			return new Cons<X>(this.fst, this.rst.sub(elem));
		}
	}
	
	// RETURNS: true iff this list contains at least an element equal to the given
	// one
	public boolean contains(X elem) {
		return this.fst.equals(elem) || this.rst.contains(elem);
	}
	
	// RETURNS: the result of traversal this list
	public <R> R traversal(IListVisitor<X, R> v) {
		return v.processCons(this.fst, this.rst);
	}
	
	// RETURNS: true iff this list contains all elements in that list
	public boolean containsList(IList<X> that) {
		if(that.empty()) {
			return true;
		}
		else {
			return this.contains(that.first()) && this.containsList(that.rest());
		}
	}
	
	// RETURNS: true iff this list is empty
	public boolean empty() {
		return false;
	}
	
	// RETURNS: the first element of this list
	public X first() {
		return this.fst;
	}
	
	// RETURNS: a list like this one, but with the first element removed
	public IList<X> rest() {
		return this.rst;
	}
	
}

interface IListVisitor<I, R>  {
	R processMt(Mt<I> mt);
	R processCons(I fst, IList<I> rst);
}

/*
// REPRESENTS: a set
interface ISet1<X>{}



class MtSet1<X> implements ISet1<X> {
	
}

class ConsSet1<X> implements ISet1<X> {
	
}
*/


class Set1<X> {
	private IList<X> elements;
	
	
	public Set1(IList<X> elements) {
		this.elements = elements;
	}
	
	public Set1() {
		this.elements = new Mt<X>();
	}
	
	// RETURNS: a set like this one, but elem added  
	public Set1<X> add(X elem) {
		return new Set1<X>(this.elements.add(elem));
	}
	
	// RETURNS: a set like this one, but with elements equal to the given one
	// removed
	public Set1<X> sub(X elem) {
		return new Set1<X>(this.elements.sub(elem));
	}
	
	// RETURNS: the intersect of this Set1 and that Set1
	public Set1<X> intersect(Set1<X> that) {
		return intersectWithList(that.elements);
	}
	
	// RETURNS: the intersect of this Set1 and the Set1 represented by
	// that IList
	private Set1<X> intersectWithList(IList<X> l) {
		if(l.empty()) {
			return new Set1<X>(new Mt<X>());
		}
		else {
			if(this.member(l.first())) {
				return this.intersectWithList(l.rest()).add(l.first());
			}
			else {
				return this.intersectWithList(l.rest());
			}
		}
	}
	
	// RETURNS: true iff this Set1 contains that Set1
	public boolean contains(Set1<X> that) {
		return 
		this.containsList(that.elements);
	}
	
	// RETURNS: true iff this Set1 contains all elements in the given list
	private boolean containsList(IList<X> l) {
		if(l.empty()) {
			return true;
		}
		else {
			return this.member(l.first()) && this.containsList(l.rest());
		}
	}
	
	// RETURNS: true iff this set contains a element that is equal to the 
	// given one
	public boolean member(X elem) {
		return this.elements.contains(elem);
	}
	
	// RETURNS: true iff this Set1 equals to that Set1
	public boolean equals(Set1<X> that) {
		return this.contains(that) && that.contains(this);
	}
}


class Set1Examples {
	IList<Integer> mt = new Mt<Integer>();
	Set1<Integer> mtSet1 = new Set1<Integer>();
	Set1<Integer> s2 = mtSet1.add(1);
	Set1<Integer> s3 = s2.add(2);
	Set1<Integer> s4 = s3.add(1);
	
	// tests for method member()
	boolean testMember(Tester t) {
		return
		t.checkExpect(s3.member(1), true) &&
		t.checkExpect(s3.member(3), false);
	}
	
	// tests for method contains()
	boolean testConatains(Tester t) {
		return
		t.checkExpect(s4.contains(mtSet1), true) &&
		t.checkExpect(mtSet1.contains(s4), true) &&
		t.checkExpect(s4.contains(s3), true) &&
		t.checkExpect(s3.contains(s4), true) &&
		t.checkExpect(s2.contains(s3), false);
	}
	
	
	// tests for method equals()
	
	// tests for method intersect()
	
	// tests for method sub()
	
	// tests for method add()
	
	// tests for method add()
	boolean testAdd(Tester t) {
		return
		true;
	}
}